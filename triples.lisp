(in-package #:vivace-graph)

(defstruct (triple
	     (:predicate triple?)
	     (:print-function print-triple)
	     (:conc-name triple-))
  (uuid (make-uuid))
  (subject nil)
  (predicate nil)
  (object nil)
  (deleted? nil)
  (graph *graph*))

(defun print-triple (triple stream depth)
  (declare (ignore depth))
  (format stream "#<TRIPLE: '~A' '~A' '~A'>" 
	  (node-value (triple-subject triple))
	  (pred-name (triple-predicate triple))
	  (node-value (triple-object triple))))

(defgeneric make-new-triple (graph subject predicate object &key index-immediate?))
(defgeneric insert-triple (triple))
(defgeneric index-triple (triple))
(defgeneric index-subject (triple))
(defgeneric index-predicate (triple))
(defgeneric index-object (triple))
(defgeneric do-indexing (graph))
(defgeneric delete-triple (triple))
(defgeneric lookup-triple (s p o &key g))
(defgeneric save-triple (triple))

(defgeneric triple-eql (t1 t2)
  (:method ((t1 triple) (t2 triple)) (uuid:uuid-eql (triple-uuid t1) (triple-uuid t2)))
  (:method (t1 t2) (error "Both arguments to triple-eql must be triples.")))

(defgeneric triple-equal (t1 t2)
  (:method ((t1 triple) (t2 triple)) 
    (and (uuid:uuid-eql (triple-uuid t1) (triple-uuid t2))
	 (node-equal (triple-subject t1) (triple-subject t2))
	 (predicate-eql (triple-predicate t1) (triple-predicate t2))
	 (node-equal (triple-object t1) (triple-object t2))))
  (:method (t1 t2) 
    (error "Both arguments to triple-equal must be triples.")))

(defmethod deserialize-help ((become (eql +triple+)) bytes)
  "Decode a triple."
  (declare (optimize (speed 3)))
  (destructuring-bind (subject predicate object id) (extract-all-subseqs bytes)
    (make-triple
     :uuid (deserialize id)
     :subject (lookup-node subject *graph* t)
     :predicate (lookup-predicate predicate *graph*)
     :object (lookup-node object *graph* t))))

(defmethod serialize ((triple triple))
  "Encode a triple for storage."
  (declare (optimize (speed 3)))
  (let ((serialized-s (make-serialized-key (triple-subject triple)))
	(serialized-p (make-serialized-key (triple-predicate triple)))
	(serialized-o (make-serialized-key (triple-object triple)))
	(serialized-id (serialize (triple-uuid triple))))
    (let* ((s-length (length serialized-s))
	   (p-length (length serialized-p))
	   (o-length (length serialized-o))
	   (id-length (length serialized-id))
	   (total-length (+ s-length p-length o-length id-length))
	   (encoded-length (encode-length total-length))
	   (length-of-encoded-length (length encoded-length)))
      (let ((serialized-triple (make-array (+ 1 length-of-encoded-length total-length) 
					   :element-type '(unsigned-byte 8))))
	(setf (aref serialized-triple 0) +triple+)
	(dotimes (i length-of-encoded-length)
	  (setf (aref serialized-triple (1+ i)) (aref encoded-length i)))
	(dotimes (i s-length)
	  (setf (aref serialized-triple (+ 1 length-of-encoded-length i)) (aref serialized-s i)))
	(dotimes (i p-length)
	  (setf (aref serialized-triple (+ 1 length-of-encoded-length s-length i)) 
		(aref serialized-p i)))
	(dotimes (i o-length)
	  (setf (aref serialized-triple (+ 1 length-of-encoded-length s-length p-length i)) 
		(aref serialized-o i)))
	(dotimes (i id-length)
	  (setf (aref serialized-triple 
		      (+ 1 length-of-encoded-length s-length p-length o-length i)) 
		(aref serialized-id i)))
	serialized-triple))))

(defun make-triple-key-from-values (s p o)
  (declare (optimize (speed 3)))
  (let ((serialized-s (serialize s))
	(serialized-p (serialize p))
	(serialized-o (serialize o)))
    (let* ((s-length (length serialized-s))
	   (p-length (length serialized-p))
	   (o-length (length serialized-o))
	   (total-length (+ s-length p-length o-length)))
      (let ((key (make-array (1+ total-length) :element-type '(unsigned-byte 8))))
	(setf (aref key 0) +triple-key+)
	(dotimes (i s-length)
	  (setf (aref key (1+ i)) (aref serialized-s i)))
	(dotimes (i p-length)
	  (setf (aref key (+ i 1 s-length)) (aref serialized-p i)))
	(dotimes (i o-length)
	  (setf (aref key (+ i 1 s-length p-length)) (aref serialized-o i)))
	key))))

(defmethod make-serialized-key ((triple triple))
  (declare (optimize (speed 3)))
  (make-triple-key-from-values (node-value (triple-subject triple))
			       (pred-name (triple-predicate triple))
			       (node-value (triple-object triple))))

(defmethod save-triple ((triple triple))
  (let ((key (make-serialized-key triple))
	(value (serialize triple)))
    (store-object (graph-db (triple-graph triple)) key value :mode :keep)))

(defun make-triple-index-key (item key-type)
  (let* ((serialized-value (serialize item))
	 (length (length serialized-value)))
    (let ((vec (make-array (1+ length) :element-type '(unsigned-byte 8))))
      (setf (aref vec 0) key-type)
      (dotimes (i length)
	(setf (aref vec (1+ i)) (aref serialized-value i)))
      vec)))
    
(defun get-indexed-triples (value index-type &optional graph)
  (mapcar #'(lambda (vec) (deserialize (lookup-object (graph-db (or graph *graph*)) vec)))
	  (lookup-objects (graph-db (or graph *graph*)) 
			  (make-triple-index-key value index-type))))

(defun get-subjects (value &optional graph)
  (get-indexed-triples value +triple-subject+ graph))

(defun get-predicates (name &optional graph)
  (get-indexed-triples (or (and (symbolp name) name) (intern name)) +triple-predicate+ graph))

(defun get-objects (value &optional graph)
  (get-indexed-triples value +triple-object+ graph))

(defmethod lookup-triple ((subject node) (predicate predicate) (object node) &key g)
  (or (gethash (list subject predicate object) (triple-cache (or g *graph*)))
      (lookup-triple (node-value subject) (pred-name predicate) (node-value object) 
		     :g (or g *graph*))))

(declaim (inline lookup-triple-in-db))
(defun lookup-triple-in-db (s p o g)
  (let ((key (make-triple-key-from-values s p o)))
    (let ((raw (lookup-object (graph-db (or g *graph*)) key)))
      (when (vectorp raw)
	(let ((triple (deserialize raw)))
	  (setf (triple-graph triple) (or g *graph*))
	  triple)))))

(defmethod lookup-triple (s p o &key g)
  (or (gethash (list s p o) (triple-cache (or g *graph*)))
      (lookup-triple-in-db s p o (or g *graph*))))

(defmethod save-triple ((triple triple))
  (let ((key (make-serialized-key triple))
	(value (serialize triple)))
    (store-object (graph-db (triple-graph triple)) key value :mode :keep)))

(defmethod cache-triple ((triple triple))
  (setf (gethash (list (node-value (triple-subject triple))
		       (pred-name (triple-predicate triple))
		       (node-value (triple-object triple)))
		 (triple-cache (triple-graph triple)))
	triple)
  (setf (gethash (list (triple-subject triple) 
		       (triple-predicate triple) 
		       (triple-object triple))
		 (triple-cache (triple-graph triple)))
	triple))

(defmethod make-new-triple ((graph graph) (subject node) (predicate predicate) (object node) 
			    &key (index-immediate? t))
  (let ((triple (make-triple :graph graph :subject subject :predicate predicate :object object)))
    (handler-case
	(with-transaction ((graph-db graph))
	  (save-triple triple)
	  (incf-ref-count subject)
	  (incf-ref-count object)
	  (index-triple triple))
      (persistence-error (condition)
	(or (lookup-triple subject predicate object)
	    (error condition)))
      (:no-error (status)
	(declare (ignore status))
	(cache-triple triple)))))

(defmethod bulk-add-triples ((graph graph) tuple-list &key cache?)
  (let ((new-triples nil))
    (handler-case
	(with-transaction ((graph-db graph))
	  (dolist (tuple tuple-list)
	    (let ((s (make-new-node :value (elt tuple 0)))
		  (p (make-new-predicate :name (elt tuple 1)))
		  (o (make-new-node :value (elt tuple 2))))
	      (or (lookup-triple-in-db (node-value s) (pred-name p) (node-value o) graph)
		  (let ((triple (make-triple :graph graph :subject s :predicate p :object o)))
		    (save-triple triple)
		    (incf-ref-count s)
		    (incf-ref-count o)
		    (index-triple triple)
		    (when cache? (push triple new-triples)))))))
      (:no-error (success?)
	(when (and success? cache?)
	  (dolist (triple new-triples)
	    (cache-triple triple))
	  t)))))
  
(defmethod delete-triple ((triple triple))
  (if (null (cas (triple-deleted? triple) nil t))
      (handler-case
	  (with-transaction ((graph-db (triple-graph triple)))
	    (delete-object (graph-db (triple-graph triple)) (make-serialized-key triple))
	    (deindex-triple triple)
	    (decf-ref-count (triple-subject triple))
	    (decf-ref-count (triple-object triple)))
	(persistence-error (condition)
	  (format t "Cannot delete triple ~A: ~A~%" triple condition))
	(:no-error (status)
	  (declare (ignore status))
	  (remhash (list (triple-subject triple) (triple-predicate triple) (triple-object triple))
		   (triple-cache (triple-graph triple)))
	  (remhash (list (node-value (triple-subject triple)) 
			 (pred-name (triple-predicate triple)) 
			 (node-value (triple-object triple)))
		   (triple-cache (triple-graph triple)))
	  t))
      t))

(defmethod index-triple ((triple triple))
  (let ((subject-key (make-triple-index-key (node-value (triple-subject triple)) 
					    +triple-subject+))
	(predicate-key (make-triple-index-key (pred-name (triple-predicate triple)) 
					      +triple-predicate+))
	(object-key (make-triple-index-key (node-value (triple-object triple)) 
					   +triple-object+))
	(triple-key (make-serialized-key triple)))
    (store-object (graph-db (triple-graph triple)) subject-key triple-key :mode :duplicate)
    (store-object (graph-db (triple-graph triple)) predicate-key triple-key :mode :duplicate)
    (store-object (graph-db (triple-graph triple)) object-key triple-key :mode :duplicate)))

(defmethod do-indexing ((graph graph))
  (loop until (sb-concurrency:queue-empty-p (needs-indexing-q graph)) do
       (index-triple (sb-concurrency:dequeue (needs-indexing-q graph)))))

(defmethod deindex-triple ((triple triple))
  (let ((subject-key (make-triple-index-key (node-value (triple-subject triple)) 
					    +triple-subject+))
	(predicate-key (make-triple-index-key (pred-name (triple-predicate triple)) 
					      +triple-predicate+))
	(object-key (make-triple-index-key (node-value (triple-object triple)) 
					   +triple-object+))
	(triple-key (make-serialized-key triple)))
    (delete-object (graph-db (triple-graph triple)) subject-key triple-key)
    (delete-object (graph-db (triple-graph triple)) predicate-key triple-key)
    (delete-object (graph-db (triple-graph triple)) object-key triple-key)))



(defun triple-test-1 ()
  (let ((*graph* (make-new-graph :name "test graph" :location "/var/tmp")))
    (unwind-protect
	 (with-transaction ((graph-db *graph*))
	   (dotimes (i 10000)
	     (add-triple (format nil "S~A" i) (format nil "P~A" i) (format nil "O~A" i))))
      (progn
	(if (graph? *graph*) (shutdown-graph *graph*))
	(delete-file "/var/tmp/triples")
	(delete-file "/var/tmp/rules")
	(delete-file "/var/tmp/config.ini")))))

(defun triple-test-2 ()
  (let ((*graph* (make-new-graph :name "test graph" :location "/var/tmp")))
    (unwind-protect
	 (let ((tuples nil))
	   (dotimes (i 10000)
	     (push (list (format nil "S~A" i) (format nil "P~A" i) (format nil "O~A" i)) tuples))
	   (time (bulk-add-triples *graph* tuples)))
      (progn
	(if (graph? *graph*) (shutdown-graph *graph*))
	(delete-file "/var/tmp/triples")
	(delete-file "/var/tmp/rules")
	(delete-file "/var/tmp/config.ini")))))

(defun triple-test-3 ()
  (let ((*graph* (make-new-graph :name "test graph" :location "/var/tmp")))
    (unwind-protect
	 (progn
	   (add-triple "Kevin" "loves" "Dustie")
	   (add-triple "Kevin" "loves" "Echo")
	   (add-triple "Dustie" "loves" "Kevin")
	   (add-triple "Echo" "loves" "cat nip")
	   (add-triple "Echo" "is-a" "cat")
	   (add-triple "Kevin" "is-a" "Homo Sapien")
	   (add-triple "Dustie" "is-a" "Homo Sapien")
	   ;;(format t "NODES ~A:~%~A~%" (nodes *graph*) (skip-list-to-list (nodes *graph*)))
	   (format t "Who loves whom? -> ~A~%" (get-triples :p "loves"))
	   (format t "What species? -> ~A~%" (get-triples :p "is-a"))
	   (format t "~A~%" (get-subjects "Kevin")))
      (progn
	(shutdown-graph *graph*)
	(delete-file "/var/tmp/triples")
	(delete-file "/var/tmp/rules")
	(delete-file "/var/tmp/config.ini")))))

