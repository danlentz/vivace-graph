(in-package #:vivace-graph)

(defstruct (triple
	     (:predicate triple?)
	     (:print-function print-triple)
	     (:conc-name triple-))
  (uuid (make-uuid))
  (subject (make-anonymous-node))
  (predicate (make-anonymous-node))
  (object (make-anonymous-node))
  (deleted? nil)
  (graph *graph*))

(defun print-triple (triple stream depth)
  (declare (ignore depth))
  (format stream "#<TRIPLE: '~A' '~A' '~A'>" 
	  (node-value (triple-subject triple))
	  (node-value (triple-predicate triple))
	  (node-value (triple-object triple))))

(defgeneric make-new-triple (graph subject predicate object &key index-immediate?))
(defgeneric insert-triple (triple))
(defgeneric index-triple (triple))
(defgeneric index-subject (triple))
(defgeneric index-predicate (triple))
(defgeneric index-object (triple))
(defgeneric do-indexing (graph))
(defgeneric delete-triple (triple))
(defgeneric lookup-triple (s p o &key g))
(defgeneric save-triple (triple))

(defmethod deserialize ((become (eql +triple+)) bytes)
  "Decode a triple."
  (declare (optimize (speed 3)))
  (let* ((triple (make-instance 'triple))
	 (subject (subseq bytes 0 (1+ (aref bytes 1))))
	 (predicate (subseq bytes (length subject) (+ 1 (length subject) 
						      (aref bytes (1+ (length subject))))))
    

(defmethod serialize ((triple triple))
  "Encode a triple for storage."
  (declare (optimize (speed 3)))
  (let ((serialized-s (make-serialized-key (triple-subject triple)))
	(serialized-p (make-serialized-key (triple-predicate triple)))
	(serialized-o (make-serialized-key (triple-object triple)))
	(serialized-id (serialize (triple-uuid triple))))
    (let* ((s-length (length serialized-s))
	   (p-length (length serialized-p))
	   (o-length (length serialized-o))
	   (id-length (length serialized-id))
	   (total-length (+ s-length p-length o-length id-length)))
      (let ((serialized-triple (make-array (+ 2 total-length) :element-type '(unsigned-byte 8))))
	(setf (aref serialized-triple 0) +triple+)
	(setf (aref serialized-triple 1) total-length)
	(dotimes (i s-length)
	  (setf (aref serialized-triple (1+ i)) (aref serialized-s i)))
	(dotimes (i p-length)
	  (setf (aref serialized-triple (+ i 1 s-length)) (aref serialized-p i)))
	(dotimes (i o-length)
	  (setf (aref serialized-triple (+ i 1 s-length p-length)) (aref serialized-o i)))
	(dotimes (i id-length)
	  (setf (aref serialized-triple (+ i 1 s-length p-length o-length)) (aref serialized-id i)))
	serialized-triple))))

(defun make-triple-key-from-values (s p o)
  (declare (optimize (speed 3)))
  (let ((serialized-s (serialize s))
	(serialized-p (serialize p))
	(serialized-o (serialize o)))
    (let* ((s-length (length serialized-s))
	   (p-length (length serialized-p))
	   (o-length (length serialized-o))
	   (total-length (+ s-length p-length o-length)))
      (let ((key (make-array (1+ total-length) :element-type '(unsigned-byte 8))))
	(setf (aref key 0) +triple-key+)
	(dotimes (i s-length)
	  (setf (aref key (1+ i)) (aref serialized-s i)))
	(dotimes (i p-length)
	  (setf (aref key (+ i 1 s-length)) (aref serialized-p i)))
	(dotimes (i o-length)
	  (setf (aref key (+ i 1 s-length p-length)) (aref serialized-o i)))
	key))))

(defmethod make-serialized-key ((triple triple))
  (declare (optimize (speed 3)))
  (make-triple-key-from-values (triple-subject triple) 
			       (triple-predicate triple) 
			       (triple-object triple)))

(defmethod save-triple ((triple triple))
  (let ((key (make-serialized-key triple))
	(value (serialize triple)))
    (store-object (graph-db (triple-graph triple)) key value :mode :keep)
    (setf (gethash (list (triple-subject triple)
			 (triple-predicate triple)
			 (triple-object triple)) 
		   (triple-cache (triple-graph triple))) 
	  triple)))

(defun make-triple-index-key (item key-type)
  (let* ((serialized-value (serialize item))
	 (length (length serialized-value)))
    (let ((vec (make-array (1+ length) :element-type '(unsigned-byte 8))))
      (setf (aref vec 0) key-type)
      (dotimes (i length)
	(setf (aref vec (1+ i)) (aref serialized-value i)))
      vec)))
    
(defun get-indexed-triples (value index-type &optional graph)
  (mapcar #'(lambda (vec) (deserialize-raw (lookup-object (graph-db (or graph *graph*)) vec)))
	  (lookup-objects (graph-db (or graph *graph*)) 
			  (make-triple-index-key value index-type))))

(defun get-subjects (value &optional graph)
  (get-indexed-triples value +triple-subject+))

(defun get-predicates (value &optional graph)
  (get-indexed-triples value +triple-predicate+))

(defun get-objects (value &optional graph)
  (get-indexed-triples value +triple-object+))

(defmethod lookup-triple ((subject node) (predicate node) (object node) &key g)
  (or (gethash (list subject predicate object) (triple-cache (or g *graph*)))
      (lookup-triple (node-value subject) (node-value predicate) (node-value object) 
		     :g (or g *graph*))))

(defmethod lookup-triple (s p o &key g)
  (or (gethash (list s p o) (triple-cache (or g *graph*)))
      (let ((key (make-triple-key-from-values s p o)))
	(let ((raw (lookup-object (graph-db (or g *graph*)) key)))
	  (when (vectorp raw)
	    (let ((triple (deserialize-raw raw)))
	      (setf (triple-graph triple) (or g *graph*))
	      triple))))))

(defmethod save-triple ((triple triple))
  (let ((key (make-serialized-key triple))
	(value (serialize triple)))
    (store-object (graph-db (triple-graph triple)) key value :mode :keep)))

(defmethod make-new-triple ((graph graph) (subject node) (predicate node) (object node) 
			    &key (index-immediate? t))
  (let ((triple (make-triple :graph graph :subject subject :predicate predicate :object object)))
    (handler-case
	(with-transaction ((graph-db graph))
	  (save-triple triple)
	  (incf-ref-count subject)
	  (incf-ref-count predicate)
	  (incf-ref-count object)
	  (index-triple triple))
      (dbm-error (condition)
	(or (lookup-triple subject predicate object)
	    (error condition)))
      (:no-error (status)
	(declare (ignore status))
	(setf (gethash (list (node-value (triple-subject triple))
			     (node-value (triple-predicate triple))
			     (node-value (triple-object triple)))
		       (triple-cache (triple-graph triple)))
	      triple)
	(setf (gethash (list (triple-subject triple) 
			     (triple-predicate triple) 
			     (triple-object triple))
		       (triple-cache (triple-graph triple)))
	      triple)))))

(defmethod delete-triple ((triple triple))
  (when (null (cas (triple-deleted? triple) nil t))
    (handler-case
	(with-transaction ((graph-db (triple-graph triple)))
	  (delete-object (make-serialized-key triple))
	  (deindex-triple triple)
	  (decf-ref-count (triple-subject triple))
	  (decf-ref-count (triple-predicate triple))
	  (decf-ref-count (triple-object triple)))
      (dbm-error (condition)
	(format t "Cannot delete triple ~A: ~A~%" triple condition))
      (:no-error (status)
	(remhash (list (triple-subject triple) (triple-predicate triple) (triple-object triple))
		 (triple-cache (triple-graph triple)))
	(remhash (list (node-value (triple-subject triple)) 
		       (node-value (triple-predicate triple)) 
		       (node-value (triple-object triple)))
		 (triple-cache (triple-graph triple)))
	t))))

(defmethod index-triple ((triple triple))
  (let ((subject-key (make-triple-index-key (node-value (triple-subject triple)) 
					    +triple-subject+))
	(predicate-key (make-triple-index-key (node-value (triple-predicate triple)) 
					      +triple-predicate+))
	(object-key (make-triple-index-key (node-value (triple-object triple)) 
					   +triple-object+))
	(triple-key (make-serialized-key triple)))
    (store-object (graph-db (triple-graph triple)) subject-key triple-key :mode :duplicate)
    (store-object (graph-db (triple-graph triple)) predicate-key triple-key :mode :duplicate)
    (store-object (graph-db (triple-graph triple)) object-key triple-key :mode :duplicate)))

(defmethod do-indexing ((graph graph))
  (loop until (sb-concurrency:queue-empty-p (needs-indexing-q graph)) do
       (index-triple (sb-concurrency:dequeue (needs-indexing-q graph)))))

(defmethod deindex-triple ((triple triple))
  (let ((subject-key (make-triple-index-key (node-value (triple-subject triple)) 
					    +triple-subject+))
	(predicate-key (make-triple-index-key (node-value (triple-predicate triple)) 
					      +triple-predicate+))
	(object-key (make-triple-index-key (node-value (triple-object triple)) 
					   +triple-object+))
	(triple-key (make-serialized-key triple)))
    (delete-object (graph-db (triple-graph triple)) subject-key triple-key)
    (delete-object (graph-db (triple-graph triple)) predicate-key triple-key)
    (delete-object (graph-db (triple-graph triple)) object-key triple-key)))



(defun triple-test-1 ()
  (let ((*graph* (make-new-graph :name "test graph" :location "/var/tmp")))
    ;;(with-transaction ((graph-db *graph*))
      (dotimes (i 10000)
	(add-triple (format nil "S~A" i) (format nil "P~A" i) (format nil "O~A" i)))
      ;;)
    (shutdown-graph *graph*)
    (delete-file "/var/tmp/db")
    (delete-file "/var/tmp/config.ini")))

(defun triple-test-2 ()
  (let ((*graph* (make-new-graph :name "test graph" :location "/var/tmp")))
    (add-triple "Kevin" "loves" "Dustie")
    (add-triple "Kevin" "loves" "Echo")
    (add-triple "Dustie" "loves" "Kevin")
    (add-triple "Echo" "loves" "cat nip")
    (add-triple "Echo" "is-a" "cat")
    (add-triple "Kevin" "is-a" "Homo Sapien")
    ;;(format t "NODES ~A:~%~A~%" (nodes *graph*) (skip-list-to-list (nodes *graph*)))
    (format t "Who loves whom? -> ~A~%" (get-triples :p "loves"))
    (format t "What species? -> ~A~%" (get-triples :p "is-a"))
    (format t "~A~%" (get-subjects "Kevin"))
    (shutdown-graph *graph*)
    (delete-file "/var/tmp/db")
    (delete-file "/var/tmp/config.ini")))
    
